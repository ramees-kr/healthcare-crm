package com.medicare.healthcarecrm.controller.api;

import com.medicare.healthcarecrm.model.Employee;
import com.medicare.healthcarecrm.service.EmployeeService;
import com.medicare.healthcarecrm.validation.OnCreate; // Import validation group
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.annotation.Validated; // Needed for group validation
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/employees")
@Tag(name = "Employee API", description = "API endpoints for managing employees")
@Validated // Enable validation groups at the class level
public class EmployeeApiController {

    private static final Logger log = LoggerFactory.getLogger(EmployeeApiController.class);

    private final EmployeeService employeeService;

    @Autowired
    public EmployeeApiController(EmployeeService employeeService) {
        this.employeeService = employeeService;
    }

    // Helper method to avoid returning password hash
    private Employee sanitizeEmployee(Employee employee) {
        if (employee != null) {
            employee.setPassword(null); // Remove password before sending response
        }
        return employee;
    }

    private List<Employee> sanitizeEmployeeList(List<Employee> employees) {
        return employees.stream().map(this::sanitizeEmployee).collect(Collectors.toList());
    }

    @GetMapping
    @Operation(summary = "Get all employees", description = "Retrieves a list of all employees (passwords omitted).")
    @ApiResponse(responseCode = "200", description = "Successfully retrieved list")
    public List<Employee> getAllEmployees() {
        log.info("API request to get all employees");
        List<Employee> employees = employeeService.getAllEmployees();
        return sanitizeEmployeeList(employees); // Omit passwords
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get employee by ID", description = "Retrieves a specific employee by their ID (password omitted).")
    @ApiResponse(responseCode = "200", description = "Employee found", content = @Content(schema = @Schema(implementation = Employee.class)))
    @ApiResponse(responseCode = "404", description = "Employee not found")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable Long id) {
        log.info("API request to get employee by ID: {}", id);
        try {
            Employee employee = employeeService.getEmployeeById(id); // Service throws exception if not found
            return ResponseEntity.ok(sanitizeEmployee(employee)); // Omit password
        } catch (RuntimeException e) { // Catch exception from service if not found
            log.warn("Employee not found for API request with ID: {}", id);
            return ResponseEntity.notFound().build();
        }
    }

    @PostMapping
    @Operation(summary = "Create a new employee", description = "Adds a new employee. Password is required and will be hashed.")
    @ApiResponse(responseCode = "201", description = "Employee created successfully", content = @Content(schema = @Schema(implementation = Employee.class)))
    @ApiResponse(responseCode = "400", description = "Invalid employee data supplied (e.g., validation error, duplicate email)")
    @ApiResponse(responseCode = "409", description = "Email already exists")
    // Apply OnCreate validation group here
    public ResponseEntity<Object> createEmployee(@Validated(OnCreate.class) @RequestBody Employee employee) {
        log.info("API request to create employee: {}", employee);
        // ID should be null for creation
        employee.setId(null);

        String error = employeeService.createEmployee(employee); // Service handles password encoding
        if (error != null) {
            log.error("API Error creating employee: {}", error);
            if (error.contains("Email already exists")) {
                return ResponseEntity.status(HttpStatus.CONFLICT).body(error); // 409 Conflict
            }
            return ResponseEntity.badRequest().body(error); // 400 Bad Request
        }
        // Important: Fetch the created employee again to get the ID generated by the DB
        // The 'employee' object passed in might not have the ID populated correctly depending on JPA config
        Employee createdEmployee = employeeService.getEmployeeById(employee.getId()); // Assuming ID gets set after save

        log.info("Employee created successfully via API with ID: {}", createdEmployee != null ? createdEmployee.getId() : "unknown");
        return ResponseEntity.status(HttpStatus.CREATED).body(sanitizeEmployee(createdEmployee)); // Omit password
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update an existing employee", description = "Updates employee details. Leave password blank or null in the request body to keep the existing password.")
    @ApiResponse(responseCode = "200", description = "Employee updated successfully", content = @Content(schema = @Schema(implementation = Employee.class)))
    @ApiResponse(responseCode = "400", description = "Invalid employee data supplied (e.g., validation error, duplicate email)")
    @ApiResponse(responseCode = "404", description = "Employee not found")
    @ApiResponse(responseCode = "409", description = "New email already exists")
    // Use default validation group for update (password not required)
    public ResponseEntity<Object> updateEmployee(@PathVariable Long id, @Valid @RequestBody Employee employee) {
        log.info("API request to update employee ID {}: {}", id, employee);
        // Ensure the ID from the path is set on the object
        employee.setId(id);

        String error = employeeService.updateEmployee(employee, id); // Service handles conditional password update/encoding
        if (error != null) {
            log.error("API Error updating employee {}: {}", id, error);
            if (error.startsWith("Employee not found")) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error); // 404 Not Found
            }
            if (error.contains("New email already exists")) {
                return ResponseEntity.status(HttpStatus.CONFLICT).body(error); // 409 Conflict
            }
            return ResponseEntity.badRequest().body(error); // 400 Bad Request
        }

        Employee updatedEmployee = employeeService.getEmployeeById(id);
        if (updatedEmployee == null) {
            log.error("Could not retrieve updated employee with ID: {}", id);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Employee updated but could not be retrieved.");
        }

        log.info("Employee updated successfully via API with ID: {}", id);
        return ResponseEntity.ok(sanitizeEmployee(updatedEmployee)); // Omit password
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete an employee", description = "Deletes an employee by their ID.")
    @ApiResponse(responseCode = "204", description = "Employee deleted successfully")
    @ApiResponse(responseCode = "404", description = "Employee not found")
    @ApiResponse(responseCode = "400", description = "Error deleting employee")
    public ResponseEntity<Object> deleteEmployee(@PathVariable Long id) {
        log.info("API request to delete employee ID: {}", id);
        String error = employeeService.deleteEmployee(id);
        if (error != null) {
            log.error("API Error deleting employee {}: {}", id, error);
            if (error.startsWith("Employee not found")) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error); // 404 Not Found
            }
            return ResponseEntity.badRequest().body(error); // 400 Bad Request
        }
        log.info("Employee deleted successfully via API with ID: {}", id);
        return ResponseEntity.noContent().build(); // 204 No Content
    }
}